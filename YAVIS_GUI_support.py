#! /usr/bin/env python
#
# Support module generated by PAGE version 4.9
# In conjunction with Tcl version 8.6
#    Apr 27, 2017 08:42:00 PM

"""
YAVIS_GUI_support.py

CSCI-729 YAVIS-My Personal Assistant

This program is the implementation of the functionalies of YAVIS and start the GUI.

author: Manan Chetan Buddhadev (mcb5345@rit.edu)
author: Nihar Vanjara (niv1676@rit.edu)
author: Atir Petkar (ap8185@rit.edu))
"""

import datetime
import os
import time
import wave
from datetime import timedelta, datetime
from os.path import join, dirname

import httplib2
import pyaudio
from apiclient import discovery
from oauth2client import client
from oauth2client import tools
from oauth2client.file import Storage
from watson_developer_cloud import ConversationV1
from watson_developer_cloud import TextToSpeechV1

import YAVIS_GUI

try:
    import argparse

    flags = argparse.ArgumentParser(parents=[tools.argparser]).parse_args()
except ImportError:
    flags = None

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk

    py3 = 0
except ImportError:
    import tkinter.ttk as ttk

    py3 = 1

# If modifying these scopes, delete your previously saved credentials
# at ~/.credentials/calendar-python-quickstart.json
SCOPES = 'https://www.googleapis.com/auth/calendar'
# SCOPES = 'https://www.googleapis.com/auth/calendar.readonly'
CLIENT_SECRET_FILE = 'client_secret.json'
APPLICATION_NAME = 'Google Calendar API Python Quickstart'


def get_credentials():
    """
    Gets valid user credentials from storage.

    If nothing has been stored, or if the stored credentials are invalid,
    the OAuth2 flow is completed to obtain the new credentials.
    
    :return: Credentials, the obtained credential
    """

    home_dir = os.path.expanduser('~')
    credential_dir = os.path.join(home_dir, '.credentials')
    if not os.path.exists(credential_dir):
        os.makedirs(credential_dir)
    credential_path = os.path.join(credential_dir,
                                   'calendar-python-quickstart.json')

    store = Storage(credential_path)
    credentials = store.get()
    if not credentials or credentials.invalid:
        flow = client.flow_from_clientsecrets(CLIENT_SECRET_FILE, SCOPES)
        flow.user_agent = APPLICATION_NAME
        if flags:
            credentials = tools.run_flow(flow, store, flags)
        else:  # Needed only for compatibility with Python 2.6
            credentials = tools.run(flow, store)
        print('Storing credentials to ' + credential_path)
    return credentials


#########################
#       message         #
#########################

conversation = ConversationV1(
    username="28a73c1d-5780-429b-a37b-69c20d45ba17",
    password="Gq56vxEAwgkd",
    version='2017-04-21')

text_to_speech = TextToSpeechV1(
    username="bddd6e2e-fee5-4b2d-b89a-f8b2463589e8",
    password="aRypNyPFGeb1",
    x_watson_learning_opt_out=True)

numOfEvents = 5


## TAPA HUA BC!
def voice(fileName):
    """
    Generates the voice for text to speech from the file provided
    Referred from: http://www.programcreek.com/python/example/52624/pyaudio.PyAudio (Example 4)
    
    :param fileName: the file to be played
    :return: None
    """

    data_chunk = 1024

    file = wave.open(fileName, "rb")

    pa = pyaudio.PyAudio()

    audio_stream = pa.open(format=pa.get_format_from_width(file.getsampwidth()),
                           channels=file.getnchannels(),
                           rate=file.getframerate(),
                           output=True)

    read_data = file.readframes(data_chunk)

    while len(read_data) != 0:
        audio_stream.write(read_data)
        read_data = file.readframes(data_chunk)

    audio_stream.close()
    pa.terminate()


def calender_google_add(date, time, event, service):
    """
    Adds an event to the Google Calendar of a user
    
    :param date: The date of the event
    :param time: The time of the event
    :param event: The title of the event
    :param service: 
    :return: None
    """

    print("Date: ", date)
    print("Time: ", time)
    print("Event: ", event)
    dt = datetime.strptime(date + "T" + time, "%Y-%m-%dT%H:%M:%S")
    dt = dt + timedelta(hours=1)
    event = {
        'summary': event,
        # 'location': '800 Howard St., San Francisco, CA 94103',
        # 'description': 'A chance to hear more about Google\'s developer products.',
        'start': {
            'dateTime': date + 'T' + time + '-04:00',
            'timeZone': 'America/New_York',
        },
        'end': {
            'dateTime': str(dt).replace(' ', 'T') + '-04:00',
            'timeZone': 'America/New_York',
        },
        'recurrence': [
            'RRULE:FREQ=DAILY;COUNT=1'
        ],
        'attendees': [
            {'email': 'lpage@example.com'},
            {'email': 'sbrin@example.com'},
        ],
        'reminders': {
            'useDefault': False,
            'overrides': [
                {'method': 'email', 'minutes': 24 * 60},
                {'method': 'popup', 'minutes': 10},
            ],
        },
    }

    event = service.events().insert(calendarId='primary', body=event).execute()


def textToSpeech(response):
    """
    Creates the file to be sent to the voice method to be played
    
    :param response: The text input received
    :return: None
    """

    with open(join(dirname(__file__), 'output.wav'),
              'wb') as audio_file:
        audio_file.write(
            text_to_speech.synthesize(response, accept='audio/wav',
                                      voice="en-US_AllisonVoice"))

    voice('output.wav')
    os.remove('output.wav')


def calendar_all(response):
    """
    Check if the input contains date, time or event-title
    
    :param response: The input received
    :return: The provided date, time and title
    """

    title = None
    for entity in response['entities']:

        if entity['entity'] == 'sys-date':
            date = entity['value']
        if entity['entity'] == 'sys-time':
            time = entity['value']
        if entity['entity'] == 'events':
            title = entity['value']

            # print(response['input']['text'])
    expression = re.findall(r'"([^"]*)"', response['input']['text'])

    if expression:
        title = expression[0]

    return date, time, title


def search_input_parser(response):
    """
    Parse the input provided by the user can decide the timeframe to search in
    
    :param response: The input received 
    :return: Date, Time, Date Interval and the Time Interval
    """

    now = datetime.now()
    d = str(now)[:10]
    t = "00:00:00"
    dayInterval = None
    timeInterval = None
    for entity in response['entities']:

        if entity['entity'] == 'Time_periods':
            timeInterval = entity['value']
        if entity['entity'] == 'sys-time':
            t = entity['value']
        if entity['entity'] == 'sys-date':
            d = entity['value']
        if entity['entity'] == 'Time_periods':
            timeInterval = entity['value']
        if entity['entity'] == 'Day_Periods':
            dayInterval = entity['value']

    return d, t, timeInterval, dayInterval


def calendar_google_search(date, t, timeInterval, dayInterval, service):
    """
    
    :param date: The date
    :param t: The time 
    :param timeInterval: The time interval 
    :param dayInterval: The day interval
    :param service: The service to search the Google Calendar event
    :return: Response containing the events
    """

    response = ""

    if dayInterval == None and timeInterval == None:

        eventsResult = service.events().list(
            calendarId='primary', timeMin=date + "T" + t + "-04:00",
            timeMax=str(datetime.strptime(date + 'T' + t, "%Y-%m-%dT%H:%M:%S") + timedelta(hours=24)).replace(' ',
                                                                                                              'T') + "-04:00",
            singleEvents=True,
            orderBy='startTime').execute()
        events = eventsResult.get('items', [])
        if not events:
            response = 'You do not have events'
        for event in events:
            start = event['start'].get('dateTime', event['start'].get('date'))
            ts = time.strptime(start[:19], "%Y-%m-%dT%H:%M:%S")
            response = response + "on " + time.strftime("%d %b,%Y at %I:%M %p,", ts) + " you have " + "\"" + event[
                'summary'] + "\"\n"

    # Show me tomorrow morning's events
    elif dayInterval == "morning":
        time_max = date + "T12:00:00-04:00"
        eventsResult = service.events().list(
            calendarId='primary', timeMin=date + "T" + "07:00:00-04:00",
            timeMax=time_max,
            singleEvents=True,
            orderBy='startTime').execute()
        events = eventsResult.get('items', [])
        if not events:
            response = 'You do not have events'
        for event in events:
            start = event['start'].get('dateTime', event['start'].get('date'))
            ts = time.strptime(start[:19], "%Y-%m-%dT%H:%M:%S")
            response = response + "on " + time.strftime("%d %b,%Y at %I:%M %p,", ts) + " you have " + "\"" + event[
                'summary'] + "\"\n"

    # show me tomorrow afternoon's events
    elif dayInterval == "afternoon":
        time_max = date + "T18:00:00-04:00"
        eventsResult = service.events().list(
            calendarId='primary', timeMin=date + "T" + "12:00:00-04:00",
            timeMax=time_max,
            singleEvents=True,
            orderBy='startTime').execute()
        events = eventsResult.get('items', [])
        if not events:
            response = 'You do not have events'

        for event in events:
            start = event['start'].get('dateTime', event['start'].get('date'))
            ts = time.strptime(start[:19], "%Y-%m-%dT%H:%M:%S")
            response = response + "on " + time.strftime("%d %b,%Y at %I:%M %p,", ts) + " you have " + "\"" + event[
                'summary'] + "\"\n"


    # Show me tomorrow evening events
    elif dayInterval == "evening":
        time_max = date + "T23:59:59-04:00"
        eventsResult = service.events().list(
            calendarId='primary', timeMin=date + "T" + "18:00:00-04:00",
            timeMax=time_max,
            singleEvents=True,
            orderBy='startTime').execute()
        events = eventsResult.get('items', [])
        if not events:
            response = 'You do not have events'

        for event in events:
            start = event['start'].get('dateTime', event['start'].get('date'))
            ts = time.strptime(start[:19], "%Y-%m-%dT%H:%M:%S")
            response = response + "on " + time.strftime("%d %b,%Y at %I:%M %p,", ts) + " you have" + "\"" + event[
                'summary'] + "\"\n"


    # show me events after 5 pm --> dayinterval = none and time_period=after
    elif timeInterval == 'after':
        time_max = date + "T23:59:59-04:00"
        eventsResult = service.events().list(
            calendarId='primary', timeMin=date + "T" + t + "-04:00",
            timeMax=time_max,
            singleEvents=True,
            orderBy='startTime').execute()
        events = eventsResult.get('items', [])
        if not events:
            response = 'You do not have events'

        for event in events:
            start = event['start'].get('dateTime', event['start'].get('date'))
            ts = time.strptime(start[:19], "%Y-%m-%dT%H:%M:%S")
            response = response + "on " + time.strftime("%d %b,%Y at %I:%M %p,", ts) + " you have " + "\"" + event[
                'summary'] + "\"\n"


    elif timeInterval == 'at':
        # time_max = date + "T23:59:59-04:00"
        eventsResult = service.events().list(
            calendarId='primary', timeMin=date + "T" + t + "-04:00",
            maxResults=1,
            singleEvents=True,
            orderBy='startTime').execute()
        events = eventsResult.get('items', [])
        if not events:
            response = 'You do not have events'

        for event in events:
            start = event['start'].get('dateTime', event['start'].get('date'))
            ts = time.strptime(start[:19], "%Y-%m-%dT%H:%M:%S")
            response = response + "on " + time.strftime("%d %b,%Y at %I:%M %p,", ts) + " you have " + "\"" + event[
                'summary'] + "\"\n"


    # show me events after 5 pm --> dayinterval = none and time_period=after
    elif timeInterval == 'before':
        time_min = date + "T00:00:00-04:00"
        eventsResult = service.events().list(
            calendarId='primary', timeMin=time_min,
            timeMax=date + "T" + t + "-04:00",
            singleEvents=True,
            orderBy='startTime').execute()
        events = eventsResult.get('items', [])
        if not events:
            response = 'You do not have events'

        for event in events:
            start = event['start'].get('dateTime', event['start'].get('date'))
            ts = time.strptime(start[:19], "%Y-%m-%dT%H:%M:%S")
            response = response + "on " + time.strftime("%d %b,%Y at %I:%M %p,", ts) + " you have " + "\"" + event[
                'summary'] + "\"\n"
    return response


def calendar_next(response):
    """
    Parse the input to retrieve results for upcoming n events
    
    :param response: The input received 
    :return: The date, the time and the number of events needed
    """

    numOfEvents = 10
    now = datetime.now()
    date = str(now)[:10]
    time = str(now)[11:19]

    for entity in response['entities']:

        if entity['entity'] == 'sys-number':
            numOfEvents = entity['value']

    return date, time, numOfEvents


def calendar_google_next(date, t, numOfEvents, service):
    """
    Retrieve results for upcoming n events
    
    :param date: The date of the event
    :param t: The time after which the events occur
    :param numOfEvents: The number of events
    :param service: The service to fetch results from the Google Calendar API
    :return: The n number of events
    """

    calendar_response = ''
    eventsResult = service.events().list(
        calendarId='primary', timeMin=date + "T" + t + "-04:00", maxResults=numOfEvents, singleEvents=True,
        orderBy='startTime').execute()
    events = eventsResult.get('items', [])
    if not events:
        calendar_response = 'No upcoming events found.'

    for event in events:
        start = event['start'].get('dateTime', event['start'].get('date'))
        ts = time.strptime(start[:19], "%Y-%m-%dT%H:%M:%S")
        calendar_response = calendar_response + "on " + time.strftime("%d %b,%Y at %I:%M %p,", ts) + "you have" + "\"" + \
                            event['summary'] + "\""
        calendar_response = calendar_response + "\n"

    return calendar_response


def send_to_watson(data, context1):
    """
    The method to communicate with Watson
    
    :param data: The user input
    :param context1: The context of the conversation to be preserved
    :return: The response to print on screen and the current context
    """

    credentials = get_credentials()
    http = credentials.authorize(httplib2.Http())
    service = discovery.build('calendar', 'v3', http=http)

    now = datetime.now()
    date = str(now)[:10]
    time = str(now)[11:19]

    # replace with your own workspace_id

    # workspace_id = '2bf137c9-65f4-4d2a-91e5-a55a4d4eea66' #Old workspace

    workspace_id = '554bed6b-fbc9-4987-a234-619480675f8c'

    i = 0
    stop = False

    while not stop:
        watson_response = ""
        calendar_response = ""

        response = conversation.message(workspace_id=workspace_id, message_input={
            'text': data}, context=context1)

        # print(json.dumps(response, indent=2))

        # Display to GUI
        # print(response['output']['text'][0])
        watson_response = response['output']['text'][0]

        if (response['output']['nodes_visited'][0] == "Calendar_Entry_add_time"
            or response['output']['nodes_visited'][0] == "Calendar_Entry_add_date_time"
            or response['output']['nodes_visited'][0] == "Calendar_Entry_add_date"):
            response['context']['add'] = True

        # now = datetime.now()
        # response['context']['date'] = str(now)[:10]

        for entity in response['entities']:

            if entity['entity'] == 'sys-date':
                response['context']['date'] = entity['value']
            if entity['entity'] == 'sys-time':
                response['context']['time'] = entity['value']
            if entity['entity'] == 'events':
                response['context']['event'] = response['input']['text']

        if response['output']['nodes_visited'][0] == "Calendar_Entry_add_All":
            date, time, title = calendar_all(response)
            response['context']['add'] = True
            response['context']['date'] = date
            response['context']['time'] = time
            response['context']['event'] = title

        if response['intents']:
            if response['intents'][0]['intent'] == 'GoodBye':
                stop = True

        if response['intents']:
            if response['intents'][0]['intent'] == "Thank_You":
                response['context']['thank_count'] += 1


                # Google Calendar Add
        if (response['context']['date'] and response['context']['time'] and
                response['context']['event'] and response['context']['add']):
            calender_google_add(response['context']['date'], response['context']['time'], response['context']['event'],
                                service)
            response['context']['date'] = None
            response['context']['time'] = None
            response['context']['event'] = None
            response['context']['add'] = None

        ##### Search
        if response['output']['nodes_visited'][0] == "Calendar_search_events":
            d, t, timeInterval, dayInterval = search_input_parser(response)
            response['context']['date'] = d
            response['context']['time'] = t
            response['context']['time_interval'] = timeInterval
            response['context']['day_interval'] = dayInterval
            response['context']['search'] = True

        if response['output']['nodes_visited'][0] == "Calendar_next_events":
            d, t, numOfEvents = calendar_next(response)
            response['context']['date'] = d
            response['context']['time'] = t
            response['context']['number_of_events'] = numOfEvents
            response['context']['next'] = True


            # Google Calendar Next Events
        if (response['context']['date'] and response['context']['time']
            and response['context']['next']):
            calendar_response = calendar_google_next(response['context']['date'], response['context']['time'],
                                                     response['context']['number_of_events'], service)
            response['context']['date'] = None
            response['context']['time'] = None
            response['context']['number_of_events'] = 10
            response['context']['next'] = False

        # Google Calendar Search Events

        if response['context']['search']:
            calendar_response = calendar_google_search(response['context']['date']
                                                       , response['context']['time']
                                                       , response['context']['time_interval']
                                                       , response['context']['day_interval'], service)

            response['context']['date'] = None
            response['context']['time'] = None
            response['context']['time_interval'] = None
            response['context']['day_interval'] = None
            response['context']['search'] = False
        print(watson_response + "\n" + " " + calendar_response + "***************")
        textToSpeech(watson_response)
        if calendar_response:
            textToSpeech(calendar_response)

        response_to_send = watson_response + "\n" + calendar_response
        context1 = response['context']
        calendar_response = ""
        return response_to_send, context1


def Button_Click(event=None):
    """
    The event handler for button click
    
    :param event: The event handler for Return key press 
    :return: None
    """

    global yavis_active
    global context
    global new_context

    data = gui_object.Entry1.get()

    if data is not "":
        if yavis_active is False:
            gui_object.scr49.insert(INSERT, 'Me: ' + data + "\n")
            gui_object.scr49.insert(INSERT, "\n")
            yavis_active = True
            response, new_context = send_to_watson(data, context)
            # print(response)
            gui_object.scr49.insert(INSERT, "YAVIS: " + response + "\n")
            gui_object.scr49.insert(INSERT, "\n")
        else:
            gui_object.scr49.insert(INSERT, "Me: " + data + "\n")
            gui_object.scr49.insert(INSERT, "\n")
            response, new_context = send_to_watson(data, new_context)
            print(response)
            gui_object.scr49.insert(INSERT, "YAVIS: " + response + "\n")
            gui_object.scr49.insert(INSERT, "\n")
    gui_object.Entry1.delete(0, 'end')

    if str(data).__contains__("Bye") or str(data).__contains__("bye"):
        exit(0)
    sys.stdout.flush()


def init(top, gui, *args, **kwargs):
    """
    The method to initialize the GUI.
    
    :param top: 
    :param gui: 
    :param args: 
    :param kwargs: 
    :return: 
    """

    global w, top_level, root, gui_object, yavis_active, context, new_context
    w = gui
    top_level = top
    root = top
    gui_object = YAVIS_GUI.Container(top_level)
    yavis_active = False
    context = {"timezone": "US/Eastern",
               "thank_count": 1,
               "date": None,
               "time": None,
               "event": None,
               "search": False,
               "add": False,
               "next": False,
               "number_of_events": 10,
               "time_interval": None,
               "day_interval": None
               }
    new_context = None


def destroy_window():
    """
    The function to close the window
    
    """

    global top_level
    top_level.destroy()
    top_level = None


if __name__ == '__main__':
    YAVIS_GUI.vp_start_gui()
